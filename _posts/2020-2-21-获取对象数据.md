---
layout: post
title: Python学习日志
---
# 学习内容
1、Python类中对象数据的获取<br>
2、Python<br>
3、Python<br>

## 一、Python类中对象数据的获取
### 实例直接调用方式
定义的类，使用自动绑定方式，直接调用，则代码编写如下：

	class Person(object):
		def __init__(self,name,age):
			self.name = name
			self.age = age
	p = Person("lieriw710",34)

### 实例间接赋值方式
如需要在调用的实例中，给某一个参数赋值，则需要在类定义的__init__方法中使用字典方式获取对象的数据，代码编写如下：

	class Person(object):
		def __init__(self.name,age,**kw):
			self.name = name
			self.age = age
			for k,v in items():  #Python3中不能使用iteritems()
				setattr(self.k,v)
	p = Person("bob","Male",age=18, couse="Python")
	print(p.age)
	print(p.course)

上面代码中setattr(self,k,v),该方法是设置属性操作 <br>
	
	>>> setattr(self.name,"wangyuhong")  # 设置新的k属性
	
	>>self.k
	>"wangyuhong"
getattr（）函数是获取属性<br>
	
	>>>getattr(self,name)
	>>>self.name
	>>>"wangyuhong"

## 二、Python中特殊方法
### Python如何把任意变量变成str？
因为任意数据类型的实例都有一个特殊方法   __str__()，<br>
我们定义一个 lst = [1,2,3],定义一个类P。对其进行操作，默认是调用__str__()方法，如下代码所示：

	>>>print(lis.__str__())
	> [1,2,3]
	>>>print(p.__str__())
	> <__main__.Person object at 0x10da938200>
Python 的特殊方法，常用的有：

	用于print 的__str__()
	用于len的__len__()
	用于cmp的__cmp__()
python de 特殊方法的特点有：
	
	特殊方法定义在class中
	不需要直接调用
	Python的某些函数或操作符会调用对应的特殊方法

正确实现特殊方法
	
	只需要编写用到的特殊方法
	有关联性的特殊方法都必须实现
		如要实现__getattr__方法，必须把__setattr__()和__delattr__都实现

### Python中的__str__和__repr__方法的使用
如果要把一个类的实例变成str,就需要实现特殊方法__str__()
	
	class Person(object):
		def __init__(self,name,gender):
			self.name = name
			self.gender = gender
		def __str__(self):
			return "(Person:%s,%s)"%(self.name,self.gender)
现在，在交互式命令行下用print打印相关数据：
	
	>>p = Person("wangyuhong","male")
	>>print(p)
	> (Person:wangyuhong,male)
但是，如果直接敲变量p：

	>>p
	><main.Person object at 0x10c134343>
似乎__str__()不会调用。<br/>
这是因为Python定义了__str__()和__repr__()两种方法，__str__()用于显示给用户，而__repr__()用于显示给开发人员。<br>
有一个偷懒的方法时在类的结尾，将

	__repr__ = __str__
### 三、多继承中，构造函数的编写
若一个类继承多个类，那么在新类中必须对父类的构造函数进行初始化，第一个继承的类可以通过调用super()函数的方法,如：

	super().__init__(name)
但第二个父类开始不能使用super()函数进行调用，必须使用未绑定方法调用父类的构造方法,如：

	Person.__init__(self.name,gender)
	Ablilty.__init__(self,skill)
### 四、Python中__cmp__的用法
对int、str等内置数据类型排序时，Python的sorted()按照默认的比较函数cmp排序，但是，如果对一组Student类的实例排序时，就必须提供我们的自己的特殊方法__cmp__().
未解决的问题，我在Python3.8编译环境下，改写类中的__cmp__()函数比较两个实例大小，运行失败，没找到好的办法。代码如下：

	class Person(object):
		def __init__(self,name,age):
			self.name = name
			self.age = age
		def __str__(self):
			return "Student:%s,%f"%(self.name,self.age)

		__repr__ = __str__

		def __cmp__(self,s):
			if self.name>s.name:
				return -1
			else:
				return 1
	p1 = Person("wangyuhong",34)
	p2 = Person("wuliping",37)
	l = [p1,p2]
	print(sorted(l))
以上代码运行错误，显示

	TypeError: '<' not supported between instances of 'Person' and 'Person'
以上问题，待会儿学习完其他的内容之后解决

###五、Python中的__len__函数
如果一个类表现得像一个list，要获取有多少个元素，就得泳道len()函数，要让len()函数正常工作，类必须提供一个特殊的方法__len__(),它返回元素的个数，例如，我们写一个Student类，把名字传进去：

	class Student(object):
		def __init__(self,*args):
			self.names = args
		def __len__(self):
			return len(self.names)

	ss = Student("Bob","Alice","Tim")
	print(len(ss)


 


			
